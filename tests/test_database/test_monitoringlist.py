import unittest
if not  hasattr(unittest.TestCase, 'assertIsInstance'):
    import unittest2 as unittest
import tkp.database as tkpdb
import tkp.database.utils as dbutils
from tkp.testutil import db_subs
#import tkp.testutil.db_queries as dbq
from tkp.testutil.decorators import requires_database
from tkp.database.utils import monitoringlist
from tkp.database.utils import associations as dbass
from tkp.database.utils import transients as tr_search


#class TestTransientCandidateMonitoring(unittest.TestCase):
#    @requires_database()
#    def setUp(self):
#        self.database = tkpdb.DataBase()
#        self.dataset = tkpdb.DataSet(data={'description':"Mon:"+self._testMethodName},
#                                    database = self.database)
#
#        self.n_images = 8                
#        self.im_params = db_subs.example_dbimage_datasets(self.n_images)
#        self.db_imgs=[]
#
#        source_lists=db_subs.example_source_lists(n_images=8,
#                                                  include_non_detections=False)
#                
#        for i in xrange(self.n_images):
#            self.db_imgs.append(
#                        tkpdb.Image(data=self.im_params[i], 
#                                            dataset=self.dataset)
#                                )
#            self.db_imgs[i].insert_extracted_sources(source_lists[i])
#            self.db_imgs[i].associate_extracted_sources(deRuiter_r=3.7)
#            
#        fixed_src_rc_entries = dbutils.columns_from_table(
#                                           self.database.connection, 
#                                           'runningcatalog',
#                                           ['id'],
#                                           alias={'id':'runcat'},
#                                           where={'dataset':self.dataset.id,
#                                                  'datapoints': self.n_images}
#                                                     )
#        self.assertEqual(len(fixed_src_rc_entries),1) #See example_source_lists() definition
#        self.fixed_src_runcatids = [i['runcat'] for i in fixed_src_rc_entries]
#             
#            
#    def tearDown(self):
#        self.database.close()
#
#    def test_winkers(self):
#        """test_winkers
#        --- Tests the SQL call which finds sources not present in all epochs
#        
#            See also: mock transients generated by `example_source_lists()`
#        """
#        
#        winkers = tkpdb.utils.select_winking_sources(
#                   self.database.connection,
#                   self.dataset.id)
#        self.assertEqual(len(winkers),3)
#        
#        #We should have 2 fast transients (1 image each)  
#        #and 1 slow transient (2 images)
#        fast_transients_counted=0
#        slow_transients_counted=0
#        for w in winkers:
#            if w['datapoints'] == 1:
#                fast_transients_counted += 1
#            if w['datapoints'] == 2:
#                slow_transients_counted += 1
#        self.assertEqual(fast_transients_counted,2)
#        self.assertEqual(slow_transients_counted,1)
#         
#        
#    def test_candidate_thresholding(self):
#        """test_candidate_thresholding
#        ---Tests the SQL which selects sources based on detection SNR levels.
#        
#         See also: mock transients generated by `example_source_lists()`
#        """
#        #Grab the source ids
#        winkers = tkpdb.utils.select_winking_sources(
#                   self.database.connection,
#                   self.dataset.id)
#        
#        all_results = tkpdb.utils.select_transient_candidates_above_thresh(
#                    self.database.connection, 
#                    [c['runcat'] for c in winkers],
#                    0,
#                    0)
#        self.assertEqual(len(winkers), len(all_results))
#
#        bright_results = tkpdb.utils.select_transient_candidates_above_thresh(
#                    self.database.connection, 
#                    [c['runcat'] for c in winkers],
#                    10,
#                    10)
#        self.assertEqual(len(bright_results), 1)
#        self.assertEqual(bright_results[0]['max_det_sigma'], 30)
#
#        #Should return bright single epoch, and fainter two epoch sources
#        solid_results = tkpdb.utils.select_transient_candidates_above_thresh(
#                    self.database.connection, 
#                    [c['runcat'] for c in winkers],
#                    3.5,
#                    6.5)
#        self.assertEqual(len(solid_results), 2)
#        self.assertAlmostEqual(solid_results[1]['max_det_sigma'], 4)
#        self.assertAlmostEqual(solid_results[1]['sum_det_sigma'], 7)
#        
##        
#    def test_full_transient_candidate_routine(self):
#        """test combined `winker` detection and `thresholding` selection.
#        
#         See also: mock transients generated by `example_source_lists()`
#        """
#        all_results = self.dataset._find_transient_candidates(0,0)
#        self.assertEqual(len(all_results),3)
#        self.assertEqual(all_results[0]['datapoints'],1)
#        self.assertEqual(all_results[1]['datapoints'],1)
#        self.assertEqual(all_results[2]['datapoints'],2)
#        self.assertAlmostEqual(all_results[2]['sum_det_sigma'], 7)
#        
#        #Now check it works with cutting thresholds:
#        solid_results = self.dataset._find_transient_candidates(
#                                      single_epoch_threshold=4,
#                                        combined_threshold=6)
#        self.assertEqual(len(solid_results),2)
#        
#        bright_results = self.dataset._find_transient_candidates(
#                                      single_epoch_threshold=8,
#                                        combined_threshold=8)
#        self.assertEqual(len(bright_results),1)
#        
#        
#    
#    def test_add_runcat_sources_to_monitoringlist(self):
#        """add_runcat_sources_to_monitoringlist
#        
#        Check that the insertion really is idempotent, 
#        i.e. checks for runcat ids before insertion.
#        """
#        runcat_entries = self.dataset.runcat_entries()
#        tkpdb.utils.add_runcat_sources_to_monitoringlist(
#                        self.database.connection,
#                        self.dataset.id, 
#                        [runcat_entries[-1]['runcat']])
#
#        mon_entries = self.db_imgs[-1].monitoringsources()
#        self.assertEqual(len(mon_entries), 1)
#        
#        #Again to check non-duplication
#        tkpdb.utils.add_runcat_sources_to_monitoringlist(
#                self.database.connection,
#                self.dataset.id, 
#                [runcat_entries[-1]['runcat']])
#
#        mon_entries = self.db_imgs[-1].monitoringsources()
#        self.assertEqual(len(mon_entries), 1)
#            
#        
#        
#        
#        
#    def test_blind_source_insertion_and_retrieval(self):
#        """test_blind_source_insertion_and_retrieval
#
#            We have faked transient sources for imgs
#            3,4,5 and 6.
#            
#            In total we have 3 different fake transients.
#            
#            Therefore we should monitor all 3 in the imgs with
#            only an extraction from the fixed source. 
#        """
#        self.dataset.mark_transient_candidates(0, 0)
#        for dbimg in self.db_imgs[0:3]:
#            srcs_to_monitor = dbimg.monitoringsources()
#            self.assertEqual(len(srcs_to_monitor),3)
#            
#            retrieved_mon_rc_ids = [src.runcat for src in srcs_to_monitor]
#            all_runcat_ids = [i['runcat'] for i in self.dataset.runcat_entries()]
#            known_mon_rcids = set(all_runcat_ids).difference(set(self.fixed_src_runcatids))
#            self.assertEqual(set(retrieved_mon_rc_ids),known_mon_rcids )
#            
#                 
#                
#        for dbimg in self.db_imgs[3:7]:
#            srcs_to_monitor = dbimg.monitoringsources()
#            self.assertEqual(len(srcs_to_monitor),2) 
#            
#    def test_monitored_source_insertion(self):
#        """
#        test_monitored_source_insertion
#        
#        - Test insertion of results for extractions caused by the monitoring list.
#        - After monitoring is complete, we expect a full 8 datapoints for 
#            each of our sources, whether fixed or transient. 
#            (we fake non-detections for all the transient monitoring extractions) 
#        """
#        self.dataset.mark_transient_candidates(0, 0)
#        for dbimg in self.db_imgs:
#            srcs_to_monitor = dbimg.monitoringsources()
##           [( ra, dec, xtrsrcid , monitorid )]
#            mon_extractions = []
#            for src in srcs_to_monitor:
#                mon_extractions.append(db_subs.ExtractedSourceTuple(ra=src[0], dec=src[1],
#                                      ra_fit_err=0.1, dec_fit_err=0.1,
#                                      peak = 0, peak_err = 5e-5,
#                                      flux = 0, flux_err = 5e-5,
#                                      sigma = 0,
#                                      beam_maj = 100, beam_min = 100,
#                                      beam_angle = 45,
#                                      ra_sys_err=20,dec_sys_err=20
#                                      )
#                                )
#            mon_results = [ (s[2],s[3],m) for  s,m in zip(srcs_to_monitor, mon_extractions)] 
#            dbimg.insert_monitored_sources(mon_results)
##       
#        n_runcat_entries = dbq.count_runcat_entries(self.database.connection, self.dataset.id)
##        print "Runcat rows:", runcat_rows
#        self.assertEqual(n_runcat_entries, 4)
#        assoc_counts = dbq.count_associated_sources(self.database.connection, self.dataset.id)
#        for count in assoc_counts:
#            self.assertEqual(count[1], 8)
##        print "Assoc counts:", assoc_counts
#        
#        
#    def test_manual_insertion(self):
#        """test_manual_insertion
#        
#            Check that manually entered entries are dealt with correctly
#        """
#        test_coords = (123.999,15.999)
#        self.dataset.add_manual_entry_to_monitoringlist(ra = test_coords[0],
#                                                        dec = test_coords[1])
##        tkpdb.utils.add_manual_entry_to_monitoringlist(
##                       self.database.connection,
##                       self.dataset.id, 
##                       )
##        print "DSID:", self.dataset.id
#        for dbimg in self.db_imgs:
#            manual_srcs = tkpdb.utils.get_monitoringlist_not_observed_manual_entries(
#                             self.database.connection,
#                             dbimg.id,
#                             self.dataset.id)
#            self.assertEqual(len(manual_srcs), 1)
#            all_srcs_to_monitor = dbimg.monitoringsources()
#            self.assertEqual(len(manual_srcs), len(all_srcs_to_monitor))
#            self.assertEqual(all_srcs_to_monitor[0].runcat,None)
#            self.assertAlmostEqual(all_srcs_to_monitor[0].ra,test_coords[0])
#            self.assertAlmostEqual(all_srcs_to_monitor[0].decl,test_coords[1])
##            print "Monitor:", all_srcs_to_monitor
#
#    def test_mixed_retrieval(self):
#        """test_mixed_retrieval
#        Tests a combination of user and automated entries to the monitoringlist
#        """
#        self.dataset.add_manual_entry_to_monitoringlist(ra = 123.999,
#                                                        dec = 15.999)
#        self.dataset.mark_transient_candidates(0, 0)
#        for dbimg in self.db_imgs[0:3]:
#            srcs_to_monitor = dbimg.monitoringsources() 
#            self.assertEqual(len(srcs_to_monitor),3+1)
#            
#        for dbimg in self.db_imgs[3:7]:
#            srcs_to_monitor = dbimg.monitoringsources()
#            self.assertEqual(len(srcs_to_monitor),2+1)
#        
#        
#class TestMonitoringCodeSpecialCases(unittest.TestCase):
#    """ Check that the code runs ok on  specific datasets.
#    
#    """
#    @requires_database()
#    def setUp(self):
#        self.database = tkpdb.DataBase()
#        self.dataset = tkpdb.DataSet(data={'description':"Mon:"+self._testMethodName},
#                                    database = self.database)
#        self.db_imgs=[]
#    def tearDown(self):
#        self.database.close()
#
#    def test_mark_transient_candidates_empty(self):
#        self.n_images = 1                
#        self.im_params = db_subs.example_dbimage_datasets(self.n_images)
#        self.db_imgs.append(
#            tkpdb.Image(data=self.im_params[0],  
#                        dataset=self.dataset)
#                    ) #Inserts a single image into the dataset
#        
#        all_results = self.dataset.mark_transient_candidates(0,0)


class TestIntermittentToMonitorlist(unittest.TestCase):
    """
    These tests will check an intermittent source, having
    a null-detection in the second image out of three images.
    This source should end up in the monitoringlist
    """
    @requires_database()
    def setUp(self):

        self.database = tkpdb.DataBase()

    def tearDown(self):
        self.database.close()

    def test_intermittentToMonitorlist(self):
        dataset = tkpdb.DataSet(database=self.database, data={'description': "Monlist:"+self._testMethodName})
        n_images = 3
        im_params = db_subs.example_dbimage_datasets(n_images)

        steady_srcs = []
        # We will work with 2 sources per image
        # one being detected in all images and not in the monlist
        # the second having a null-detection in the second image
        # and stored in the monlist
        n_steady_srcs = 2 
        for i in range(n_steady_srcs):
            src = db_subs.example_extractedsource_tuple()
            src = src._replace(ra=src.ra + 2 * i)
            steady_srcs.append(src)

        im_nr = 1
        for im in im_params:
            image = tkpdb.Image(database=self.database, dataset=dataset, data=im)
            
            if im_nr == 2:
                # The second image has a null detection, so only the first source is detected
                image.insert_extracted_sources(steady_srcs[0:1])
            else:
                image.insert_extracted_sources(steady_srcs)
            
            # First, we check for null detections
            nd = monitoringlist.get_nulldetections(image.id, deRuiter_r = 3.717)
            print "nd =", nd
            print "len(nd) =", len(nd)
            
            if im_nr == 1:
                self.assertEqual(len(nd), 0)
            elif im_nr == 2:
                self.assertEqual(len(nd), 1)
                # The null detection is found,
                # We simulate the forced fit result back into extractedsource
                # Check that the null-detection ra is the ra of source two
                self.assertEqual(nd[0][0][0], steady_srcs[1].ra)
                #print "nd=",nd
                tuple_ff_nd = steady_srcs[1:2]
                monitoringlist.insert_forcedfits_into_extractedsource(image.id, tuple_ff_nd, 'ff_nd')
            elif im_nr == 3:
                self.assertEqual(len(nd), 0)
            
            # Secondly, we do the source association
            dbass.associate_extracted_sources(image.id, deRuiter_r = 3.717)
            monitoringlist.add_nulldetections(image.id)
            # We also need to run the transient search in order to pick up the variable
            # eta_lim, V_lim, prob_threshold, minpoints, resp.
            transients = tr_search.transient_search(image.id, \
                                                     0.0, \
                                                     0.0, \
                                                     0.5, \
                                                     1)
            
            # Adjust (insert/update/remove) transients in monlist as well
            monitoringlist.adjust_transients_in_monitoringlist(image.id, \
                                                               transients)
            im_nr += 1
           
        # So after the three images have been processed,
        # We should have the null-detection source in the monlist
        
        # Get the null detection in extractedsource
        # These are of extract_type = 1
        query = """\
        select x.id 
          from extractedsource x
              ,image i 
         where x.image = i.id 
           and i.dataset = %s
           and x.extract_type = 1
        """ 
        self.database.cursor.execute(query, (dataset.id,))
        result = zip(*self.database.cursor.fetchall())
        null_det = result[0]
        self.assertEqual(len(null_det), 1)

        query = """\
        select a.runcat
              ,a.xtrsrc
              ,r.wm_ra
              ,r.wm_decl
          from assocxtrsource a
              ,extractedsource x
              ,image i
              ,runningcatalog r
         where a.xtrsrc = x.id
           and x.id = %s
           and x.image = i.id
           and i.dataset = %s
           and a.runcat = r.id
           and r.dataset = i.dataset
        """
        self.database.cursor.execute(query, (null_det[0], dataset.id,))
        result = zip(*self.database.cursor.fetchall())
        assocruncat = result[0]
        xtrsrc = result[1]
        wm_ra = result[2]
        wm_decl = result[3]
        self.assertEqual(len(assocruncat), 1)

        query = """\
        SELECT runcat
              ,ra
              ,decl
          FROM monitoringlist
         WHERE dataset = %s
        """
        self.database.cursor.execute(query, (dataset.id,))
        result = zip(*self.database.cursor.fetchall())
        print "len(result)=",len(result)
        self.assertEqual(len(result), 3)
        #self.assertEqual(0, 1)
        monruncat = result[0]
        ra = result[1]
        decl = result[2]
        self.assertEqual(len(monruncat), 1)
        self.assertEqual(monruncat[0], assocruncat[0])
        self.assertEqual(ra[0], wm_ra[0])
        self.assertEqual(decl[0], wm_decl[0])

class TestVariableToMonitorlist(unittest.TestCase):
    """
    These tests will check an intermittent source, having
    a null-detection in the second image out of three images.
    This source should end up in the monitoringlist
    """
    @requires_database()
    def setUp(self):

        self.database = tkpdb.DataBase()

    def tearDown(self):
        self.database.close()

    def test_variableToMonitorlist(self):
        dataset = tkpdb.DataSet(database=self.database, data={'description': "Monlist:"+self._testMethodName})
        n_images = 3
        im_params = db_subs.example_dbimage_datasets(n_images)

        steady_srcs = []
        # We will work with 2 sources per image
        # one being constant in all images and not ending up in the monlist,
        # while the second showing flux increase in the second image
        # and should be stored in the monlist
        n_steady_srcs = 2 
        for i in range(n_steady_srcs):
            src = db_subs.example_extractedsource_tuple()
            src = src._replace(ra=src.ra + 2 * i)
            steady_srcs.append(src)

        im_nr = 1
        for im in im_params:
            image = tkpdb.Image(database=self.database, dataset=dataset, data=im)
            
            if im_nr == 2:
                # flux of second source spikes
                steady_srcs[1] = steady_srcs[1]._replace(flux=15e-2)
            else:
                steady_srcs[1] = steady_srcs[1]._replace(flux=15e-3)
            
            image.insert_extracted_sources(steady_srcs)

            ff_nd = monitoringlist.get_nulldetections(image.id, deRuiter_r = 3.717)
            ff_mon = monitoringlist.get_monsources(image.id, deRuiter_r = 3.717)
            print "len(ff_nd)=",len(ff_nd)
            print "ff_nd=",ff_nd
            print "len(ff_mon)=",len(ff_mon)
            print "ff_mon=",ff_mon
            
            # No forced fits
            self.assertEqual(len(ff_mon), 0)
            self.assertEqual(len(ff_mon), 0)
            
            # Then we do the source association
            dbass.associate_extracted_sources(image.id, deRuiter_r = 3.717)
            monitoringlist.add_nulldetections(image.id)     
            # We also need to run the transient search in order to pick up the variable
            # eta_lim, V_lim, prob_threshold, minpoints, resp.
            transients = tr_search.transient_search(image.id, \
                                                     0.0, \
                                                     0.0, \
                                                     0.5, \
                                                     1)
            
            # Adjust (insert/update/remove) transients in monlist as well
            monitoringlist.adjust_transients_in_monitoringlist(image.id, \
                                                               transients)
            im_nr += 1
           
        # So after the three images have been processed,
        # We should have the variable source in the monlist
        
        query = """\
        SELECT runcat
              ,ra
              ,decl
          FROM monitoringlist
         WHERE dataset = %s
        """
        self.database.cursor.execute(query, (dataset.id,))
        result = zip(*self.database.cursor.fetchall())
        self.assertEqual(len(result), 3)
        #self.assertEqual(1, 3)
        monruncat = result[0]
        ra = result[1]
        decl = result[2]
        self.assertEqual(len(monruncat), 1)
        self.assertEqual(ra[0], steady_srcs[1].ra)
        self.assertEqual(decl[0], steady_srcs[1].dec)
